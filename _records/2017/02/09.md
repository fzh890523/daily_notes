

# 内核代码里是否用到信号量之类的东西



## 引子

JS:
请教下:
JS:
   信号量不允许使用在中断中怎么理解啊？ 
w@eleme:
因为中断上下文内，处理过程是不能睡眠或者放弃CPU的，而信号量可能会因为抢不到信号量而导致当前程序睡眠。所以信号量不能用在中断内。

JS:
@w@饿了么  谢谢  中断上下文  已经到内核空间了吧   内核空间一般开发人员是用不到信号量了吧。
我:
嗯，我也纳闷的是，ISR在内核空间，有信号量可以用吗？

我:
大佬大佬。 刚才的问题，我记得不太清楚了。 帮忙解答一下。
1\. 内核代码有信号量之类的东西可以用吗
2\. “因为中断上下文内，处理过程是不能睡眠或者放弃CPU的”这个的原因是什么？
   :
1\. 因为中断都在内核态，所以本来就不能用，以至于干脆就没做。 2. 因为硬件要求。。。
   我:
   嗯第一个我也是这么理解的，但又搜到内核态信号量的说法，我再确认一下。
   第二个的话，硬件自然要求ISR尽快处理完，但如果真的睡眠或者放弃CPU的话又会怎么样呢？ 这个“要求”没法强制吧。
   :
   第一个，内核里确实有 sema_init 这个函数，但是。。。
   :
   我忘了。。。
   我:
   逻辑上来说，内核代码的执行路径之间也应该有资源保护等需求。 但ISR只要把状态反馈就够了所以一般不会。 这里等于是两个问题。
   :
   第二个，ISR是打断执行的你造不，一旦放弃CPU，却不能释放处理栈，则系统无法再对这个线程进行调度，会导致某种意义上的 循环等待。
   :
   也就是死锁的普遍形式。。。
   我:
   嗯。有点印象，但是忘球了。 我再去看看书。 
   我:
   羡慕学的扎实的大佬。



## semaphore实现

ref:

*  [How are semaphores implemented in the Linux kernel?](https://www.quora.com/How-are-semaphores-implemented-in-the-Linux-kernel)

   ```c
   /*
   * trylock for reading -- returns 1 if successful, 0 if contention
   */
   int down_read_trylock(struct rw_semaphore *sem)
   {
          int ret = __down_read_trylock(sem);
          if (ret == 1) {
                  rwsem_acquire_read(&sem->dep_map, 0, 1, _RET_IP_);
                  rwsem_set_reader_owned(sem);
          }
          return ret;
   }

     // ...

     static inline bool __down_read_trylock(struct rw_semaphore *sem)
     {
             long result, tmp;
             asm volatile("# beginning __down_read_trylock\n\t"
                          "  mov          %0,%1\n\t"
                          "1:\n\t"
                          "  mov          %1,%2\n\t"
                          "  add          %3,%2\n\t"
                          "  jle          2f\n\t"
                          LOCK_PREFIX "  cmpxchg  %2,%0\n\t"
                          "  jnz          1b\n\t"
                          "2:\n\t"
                          "# ending __down_read_trylock\n\t"
                          : "+m" (sem->count), "=&a" (result), "=&r" (tmp)
                          : "i" (RWSEM_ACTIVE_READ_BIAS)
                          : "memory", "cc");
             return result >= 0;
     }

     // ...

     /*
   *  If there are no writers and no waiting writers, down_read()
   *  acquires the rwsem
           */
          static inline void down_read(struct rw_semaphore *sem)
          {
             spin_lock(&sem->lock);
             dump_rwsem(__FUNCTION__ " in", sem);
             if (sem->nr_holders < 0 || waitqueue_active(&sem->writers_wait))
                 down_read_wait(sem);
             sem->nr_holders++;
             dump_rwsem(__FUNCTION__ " out", sem);
             spin_unlock(&sem->lock);
          }
          
          // ...
          
          /*
      * down_read() failed to acquire the rwsem.  We sleep
      * until there are no writers holding it and no writers
      * requesting it.
        */
        void down_read_wait(struct rw_semaphore *sem)
        {
        struct task_struct *tsk = current;
        DECLARE_WAITQUEUE(wait, tsk);
        dump_rwsem(__FUNCTION__ " in", sem);
        __add_wait_queue(&sem->readers_wait, &wait);
        do {
            __set_task_state(tsk, TASK_UNINTERRUPTIBLE);
            spin_unlock(&sem->lock);
            schedule();
            spin_lock(&sem->lock);
        } while (sem->nr_holders < 0 || waitqueue_active(&sem->writers_wait));
        __remove_wait_queue(&sem->readers_wait, &wait);
        dump_rwsem(__FUNCTION__ " out", sem);
        }
        EXPORT_SYMBOL_NOVERS(down_read_wait);
   ```


* [信号量学习笔记](http://blog.csdn.net/yongan1006/article/details/6682418) or [local](resource/信号量学习笔记 - yongan1006的专栏 - 博客频道 - CSDN.NET.html)
* [linux 内核信号量 用户态信号量 详解](http://blog.csdn.net/weed_hz/article/details/8965733) or [local](resource/linux 内核信号量 用户态信号量 详解 - weed_hz的专栏 - 博客频道 - CSDN.NET.htm)
* [Linux 内核信号量与用户态信号量（System V&POSIX）总结](http://www.360doc.com/content/12/0723/00/9298584_225900606.shtml) or [local](resource/Linux 内核信号量与用户态信号量（System V&POSIX）总结.htm)




## 内核semaphore vs 用户态（glibc）semaphore

* 内核semaphore
  * 给内核和驱动程序使用，而***不是glibc semaphore的内核实现***
  * 看代码（如前面ref里的）是单独实现（内核空间就无所谓syscall之类了）
* glibc semaphore
  * 给应用程序使用
  * 看glibc代码是基于`atomic+futex`



## 内核semaphore



### 介绍



**数据结构**

```c
struct semaphore {
　　 atomic_t count;
　　 int sleepers;
　　 wait_queue_head_t wait;
　　}
```

**内核信号量的相关函数**

初始化：

```c
void sema_init (struct semaphore *sem, int val);
void init_MUTEX (struct semaphore *sem); //将sem的值置为1，表示资源空闲
void init_MUTEX_LOCKED (struct semaphore *sem); //将sem的值置为0，表示资源忙
```

**申请内核信号量所保护的资源：**

```c
void down(struct semaphore * sem); // 可引起睡眠
int down_interruptible(struct semaphore * sem); // down_interruptible能被信号打断
int down_trylock(struct semaphore * sem); // 非阻塞函数，不会睡眠。无法锁定资源则马上返回
```

**释放内核信号量所保护的资源：**

```c
void up(struct semaphore * sem);
```



### source code

实现见上面的...。

```c
/*
 * Copyright (c) 2008 Intel Corporation
 * Author: Matthew Wilcox <willy@linux.intel.com>
 *
 * Distributed under the terms of the GNU GPL, version 2
 *
 * This file implements counting semaphores.
 * A counting semaphore may be acquired 'n' times before sleeping.
 * See mutex.c for single-acquisition sleeping locks which enforce
 * rules which allow code to be debugged more easily.
 */

/*
 * Some notes on the implementation:
 *
 * The spinlock controls access to the other members of the semaphore.
 * down_trylock() and up() can be called from interrupt context, so we
 * have to disable interrupts when taking the lock.  It turns out various
 * parts of the kernel expect to be able to use down() on a semaphore in
 * interrupt context when they know it will succeed, so we have to use
 * irqsave variants for down(), down_interruptible() and down_killable()
 * too.
 *
 * The ->count variable represents how many more tasks can acquire this
 * semaphore.  If it's zero, there may be tasks waiting on the wait_list.
 */

#include <linux/compiler.h>
#include <linux/kernel.h>
#include <linux/export.h>
#include <linux/sched.h>
#include <linux/semaphore.h>
#include <linux/spinlock.h>
#include <linux/ftrace.h>

static noinline void __down(struct semaphore *sem);
static noinline int __down_interruptible(struct semaphore *sem);
static noinline int __down_killable(struct semaphore *sem);
static noinline int __down_timeout(struct semaphore *sem, long timeout);
static noinline void __up(struct semaphore *sem);

/**
 * down - acquire the semaphore
 * @sem: the semaphore to be acquired
 *
 * Acquires the semaphore.  If no more tasks are allowed to acquire the
 * semaphore, calling this function will put the task to sleep until the
 * semaphore is released.
 *
 * Use of this function is deprecated, please use down_interruptible() or
 * down_killable() instead.
 */
void down(struct semaphore *sem)
{
	unsigned long flags;

	raw_spin_lock_irqsave(&sem->lock, flags);
	if (likely(sem->count > 0))
		sem->count--;
	else
		__down(sem);
	raw_spin_unlock_irqrestore(&sem->lock, flags);
}
EXPORT_SYMBOL(down);

/**
 * down_interruptible - acquire the semaphore unless interrupted
 * @sem: the semaphore to be acquired
 *
 * Attempts to acquire the semaphore.  If no more tasks are allowed to
 * acquire the semaphore, calling this function will put the task to sleep.
 * If the sleep is interrupted by a signal, this function will return -EINTR.
 * If the semaphore is successfully acquired, this function returns 0.
 */
int down_interruptible(struct semaphore *sem)
{
	unsigned long flags;
	int result = 0;

	raw_spin_lock_irqsave(&sem->lock, flags);
	if (likely(sem->count > 0))
		sem->count--;
	else
		result = __down_interruptible(sem);
	raw_spin_unlock_irqrestore(&sem->lock, flags);

	return result;
}
EXPORT_SYMBOL(down_interruptible);

/**
 * down_killable - acquire the semaphore unless killed
 * @sem: the semaphore to be acquired
 *
 * Attempts to acquire the semaphore.  If no more tasks are allowed to
 * acquire the semaphore, calling this function will put the task to sleep.
 * If the sleep is interrupted by a fatal signal, this function will return
 * -EINTR.  If the semaphore is successfully acquired, this function returns
 * 0.
 */
int down_killable(struct semaphore *sem)
{
	unsigned long flags;
	int result = 0;

	raw_spin_lock_irqsave(&sem->lock, flags);
	if (likely(sem->count > 0))
		sem->count--;
	else
		result = __down_killable(sem);
	raw_spin_unlock_irqrestore(&sem->lock, flags);

	return result;
}
EXPORT_SYMBOL(down_killable);

/**
 * down_trylock - try to acquire the semaphore, without waiting
 * @sem: the semaphore to be acquired
 *
 * Try to acquire the semaphore atomically.  Returns 0 if the semaphore has
 * been acquired successfully or 1 if it it cannot be acquired.
 *
 * NOTE: This return value is inverted from both spin_trylock and
 * mutex_trylock!  Be careful about this when converting code.
 *
 * Unlike mutex_trylock, this function can be used from interrupt context,
 * and the semaphore can be released by any task or interrupt.
 */
int down_trylock(struct semaphore *sem)
{
	unsigned long flags;
	int count;

	raw_spin_lock_irqsave(&sem->lock, flags);
	count = sem->count - 1;
	if (likely(count >= 0))
		sem->count = count;
	raw_spin_unlock_irqrestore(&sem->lock, flags);

	return (count < 0);
}
EXPORT_SYMBOL(down_trylock);

/**
 * down_timeout - acquire the semaphore within a specified time
 * @sem: the semaphore to be acquired
 * @timeout: how long to wait before failing
 *
 * Attempts to acquire the semaphore.  If no more tasks are allowed to
 * acquire the semaphore, calling this function will put the task to sleep.
 * If the semaphore is not released within the specified number of jiffies,
 * this function returns -ETIME.  It returns 0 if the semaphore was acquired.
 */
int down_timeout(struct semaphore *sem, long timeout)
{
	unsigned long flags;
	int result = 0;

	raw_spin_lock_irqsave(&sem->lock, flags);
	if (likely(sem->count > 0))
		sem->count--;
	else
		result = __down_timeout(sem, timeout);
	raw_spin_unlock_irqrestore(&sem->lock, flags);

	return result;
}
EXPORT_SYMBOL(down_timeout);

/**
 * up - release the semaphore
 * @sem: the semaphore to release
 *
 * Release the semaphore.  Unlike mutexes, up() may be called from any
 * context and even by tasks which have never called down().
 */
void up(struct semaphore *sem)
{
	unsigned long flags;

	raw_spin_lock_irqsave(&sem->lock, flags);
	if (likely(list_empty(&sem->wait_list)))
		sem->count++;
	else
		__up(sem);
	raw_spin_unlock_irqrestore(&sem->lock, flags);
}
EXPORT_SYMBOL(up);

/* Functions for the contended case */

struct semaphore_waiter {
	struct list_head list;
	struct task_struct *task;
	bool up;
};

/*
 * Because this function is inlined, the 'state' parameter will be
 * constant, and thus optimised away by the compiler.  Likewise the
 * 'timeout' parameter for the cases without timeouts.
 */
static inline int __sched __down_common(struct semaphore *sem, long state,
								long timeout)
{
	struct task_struct *task = current;
	struct semaphore_waiter waiter;

	list_add_tail(&waiter.list, &sem->wait_list);
	waiter.task = task;
	waiter.up = false;

	for (;;) {
		if (signal_pending_state(state, task))
			goto interrupted;
		if (unlikely(timeout <= 0))
			goto timed_out;
		__set_task_state(task, state);
		raw_spin_unlock_irq(&sem->lock);
		timeout = schedule_timeout(timeout);
		raw_spin_lock_irq(&sem->lock);
		if (waiter.up)
			return 0;
	}

 timed_out:
	list_del(&waiter.list);
	return -ETIME;

 interrupted:
	list_del(&waiter.list);
	return -EINTR;
}

static noinline void __sched __down(struct semaphore *sem)
{
	__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);
}

static noinline int __sched __down_interruptible(struct semaphore *sem)
{
	return __down_common(sem, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);
}

static noinline int __sched __down_killable(struct semaphore *sem)
{
	return __down_common(sem, TASK_KILLABLE, MAX_SCHEDULE_TIMEOUT);
}

static noinline int __sched __down_timeout(struct semaphore *sem, long timeout)
{
	return __down_common(sem, TASK_UNINTERRUPTIBLE, timeout);
}

static noinline void __sched __up(struct semaphore *sem)
{
	struct semaphore_waiter *waiter = list_first_entry(&sem->wait_list,
						struct semaphore_waiter, list);
	list_del(&waiter->list);
	waiter->up = true;
	wake_up_process(waiter->task);
}

```

可以看到，`interruptable`, `killable`, `uninterruptable` 这几种up/down的方式区别在于将task设置为什么状态，默认为uninterruptable。

### 使用

```c
    static ssize_t globarl_var(struct file *file, const char __user *ubuf,  
        size_t count,loff_t *offp)  
    {  
    //试图获得信号量，用可被信号打断方式  
            if(down_interruptible(&sema) < 0){  
                return -ERESTARTSYS;  
            }  
    //对共享资源(global_var)进行操作  
            if(copy_from_user(&global_var, buf, sizeof(int))){  
    //失败也要进行释放信号量，要不死锁了  
                up(&sema);  
                return -EFAULT;  
            }  
    //成功释放信号量     
            up(&sema);  
              
            return sizeof(int);  
    }  
```



#### 示例

```c
// /drivers/staging/vc04_services/interface/vchiq_arm/vchiq_util.h

typedef struct {
	int size;
	int read;
	int write;
	int initialized;

	struct semaphore pop;
	struct semaphore push;

	VCHIQ_HEADER_T **storage;
} VCHIU_QUEUE_T;

// ...

int vchiu_queue_init(VCHIU_QUEUE_T *queue, int size)
{
	WARN_ON(!is_pow2(size));

	queue->size = size;
	queue->read = 0;
	queue->write = 0;
	queue->initialized = 1;

	sema_init(&queue->pop, 0);
	sema_init(&queue->push, 0);

	queue->storage = kzalloc(size * sizeof(VCHIQ_HEADER_T *), GFP_KERNEL);
	if (queue->storage == NULL) {
		vchiu_queue_delete(queue);
		return 0;
	}
	return 1;
}

// ...

static void
free_pagelist(struct vchiq_pagelist_info *pagelistinfo,
	      int actual)
{
	unsigned int i;
	PAGELIST_T *pagelist   = pagelistinfo->pagelist;
	struct page **pages    = pagelistinfo->pages;
	unsigned int num_pages = pagelistinfo->num_pages;

	vchiq_log_trace(vchiq_arm_log_level, "free_pagelist - %pK, %d",
			pagelistinfo->pagelist, actual);

	/*
	 * NOTE: dma_unmap_sg must be called before the
	 * cpu can touch any of the data/pages.
	 */
	dma_unmap_sg(g_dev, pagelistinfo->scatterlist,
		     pagelistinfo->num_pages, pagelistinfo->dma_dir);
	pagelistinfo->scatterlist_mapped = 0;

	/* Deal with any partial cache lines (fragments) */
	if (pagelist->type >= PAGELIST_READ_WITH_FRAGMENTS) {
		char *fragments = g_fragments_base +
			(pagelist->type - PAGELIST_READ_WITH_FRAGMENTS) *
			g_fragments_size;
		int head_bytes, tail_bytes;
		head_bytes = (g_cache_line_size - pagelist->offset) &
			(g_cache_line_size - 1);
		tail_bytes = (pagelist->offset + actual) &
			(g_cache_line_size - 1);

		if ((actual >= 0) && (head_bytes != 0)) {
			if (head_bytes > actual)
				head_bytes = actual;

			memcpy((char *)page_address(pages[0]) +
				pagelist->offset,
				fragments,
				head_bytes);
		}
		if ((actual >= 0) && (head_bytes < actual) &&
			(tail_bytes != 0)) {
			memcpy((char *)page_address(pages[num_pages - 1]) +
				((pagelist->offset + actual) &
				(PAGE_SIZE - 1) & ~(g_cache_line_size - 1)),
				fragments + g_cache_line_size,
				tail_bytes);
		}

		down(&g_free_fragments_mutex);
		*(char **)fragments = g_free_fragments;
		g_free_fragments = fragments;
		up(&g_free_fragments_mutex);
		up(&g_free_fragments_sema);
	}

	/* Need to mark all the pages dirty. */
	if (pagelist->type != PAGELIST_WRITE &&
	    pagelistinfo->pages_need_release) {
		for (i = 0; i < num_pages; i++)
			set_page_dirty(pages[i]);
	}

	cleaup_pagelistinfo(pagelistinfo);
}
```



## glibc semaphore实现



### 介绍

* POSIX信号量

  非负整数

  常用于线程同步

  * 无名信号量

    常用于多线程间的同步，同时也用于相关进程间的同步。也就是说，无名信号量必须是多个进程（线程）的共享变量，无名信号量要保护的变量也必须是多个进程（线程）的共享变量，这两个条件是缺一不可的

    ​

    **支持操作**如下：

    * init

      ```c
      int sem_init(sem_t *sem, int pshared, unsigned int value);
      ```

      > 1) pshared==0 用于同一多线程的同步；
      >
      > 2) 若pshared>0 用于多个相关进程间的同步（即由fork产生的）

    * getvalue

      ```C
      int sem_getvalue(sem_t *sem, int *sval);
      ```

      > 取回信号量sem的当前值，把该值保存到sval中。
      >
      > 若有1个或更多的线程或进程调用sem_wait阻塞在该信号量上，该函数返回两种值：
      >
      > 1) 返回0
      >
      > 2) 返回阻塞在该信号量上的进程或线程数目
      >
      > linux采用返回的第一种策略。

    * wait

      sem_wait(或sem_trywait)相当于P操作，即申请资源。

      ```c
      int sem_wait(sem_t *sem);     // 这是一个阻塞的函数
      ```

      > 测试所指定信号量的值,它的操作是原子的。
      >
      > 若sem>0，那么它减1并立即返回。
      > 若sem==0，则睡眠直到sem>0，此时立即减1，然后返回。

      ```c
      int sem_trywait(sem_t *sem);   // 非阻塞的函数
      ```

      > 其他的行为和sem_wait一样，除了： 若sem==0，不是睡眠，而是返回一个错误EAGAIN。

    * post

      sem_post相当于V操作，释放资源。

      ```c
      int sem_post(sem_t *sem);
      ```

      > 把指定的信号量sem的值加1;
      >
      > 呼醒正在等待该信号量的任意线程。

    注意：在这些函数中，只有sem_post是信号安全的函数，它是可重入函数

    ​

    **操作样例**

    线程间

    ```c
    #include <pthread.h>
    #include <semaphore.h>
    #include <sys/types.h>
    #include <stdio.h>
    #include <unistd.h>

    int number;   // 被保护的全局变量
    sem_t sem_id;

    void* thread_one_fun(void *arg)
    {
        sem_wait(&sem_id);
        printf("thread_one have the semaphore\n");
        number++;
        printf("number = %d\n",number);
        sem_post(&sem_id);
    }

    void* thread_two_fun(void *arg)
    {
        sem_wait(&sem_id);
        printf("thread_two have the semaphore \n");
        number--;
        printf("number = %d\n",number);
        sem_post(&sem_id);
    }

    int main(int argc,char *argv[])
    {
        number = 1;
        pthread_t id1, id2;
        sem_init(&sem_id, 0, 1);
        
        pthread_create(&id1,NULL,thread_one_fun, NULL);
        pthread_create(&id2,NULL,thread_two_fun, NULL);
        pthread_join(id1,NULL);
        pthread_join(id2,NULL);
        
        printf("main,,,\n");
        
        return 0;
    }
    ```

    ​

    进程间 - 用mmap文件得到的内存地址来跨进程共享

    ```c
    #include <semaphore.h>
    #include <stdio.h>
    #include <errno.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <fcntl.h>
    #include <sys/mman.h>

    int main(int argc, char **argv)
    {
        int fd, i,count=0,nloop=10,zero=0,*ptr;
        sem_t mutex;

        //open a file and map it into memory
        fd = open("log.txt",O_RDWR|O_CREAT,S_IRWXU);
        write(fd,&zero,sizeof(int));
        ptr = mmap( NULL,sizeof(int),PROT_READ |PROT_WRITE,MAP_SHARED,fd,0 );
        close(fd);

        /* create, initialize semaphore */
        if( sem_init(&mutex,1,1) < 0)  //
        {
            perror("semaphore initilization");
            exit(0);
        }

        if (fork() == 0)
        { /* child process*/
        	for (i = 0; i < nloop; i++)
    		{
                sem_wait(&mutex);
                printf("child: %d\n", (*ptr)++);
                sem_post(&mutex);
    		}
            exit(0);
    	}

        /* back to parent process */
    	for (i = 0; i < nloop; i++)
    	{
    		sem_wait(&mutex);
            printf("parent: %d\n", (*ptr)++);
            sem_post(&mutex);
    	}

        exit(0);
    }
    ```

  * 有名信号量

    和无名信号量共享sem_wait和sem_post函数。

    区别是有名信号量使用sem_open代替sem_init，另外在结束的时候要像关闭文件一样去关闭这个有名信号量。

    **操作**如下：

    * open

      ```c
      sem_t *sem_open(const char *name,  int oflag, mode_t mode , int value);
      ```

      > name是文件的路径名（在linux下，sem都是创建在/dev/shm目录下
      >
      > ，所以只需要文件名）；
      >
      > oflag 有O_CREAT或O_CREAT|EXCL两个取值；
      >
      > mode_t控制新的信号量的访问权限；
      >
      > value指定信号量的初始化值。

    * close

      ```c
      int sem_close(sem_t *sem);
      ```

      > sem_close() closes the named semaphore referred to by sem, allowing any resources that the system has allocated to the calling process for this semaphore to be freed.

    * unlink

      ```c
      int sem_unlink(const char *name);
      ```

      > sem_unlink() removes the named semaphore referred to by name.  The semaphore name is removed immediately.  The semaphore is destroyed once all other processes that have the semaphore open close it.
      >
      > 注意如果有任何的处理器或是线程引用这个信号量，sem_unlink()函数不会起到任何的作用。也就是说，必须是最后一个使用该信号量的进程来执行sem_unlick才有效。

  ​

  **使用样例**

  ```c
  // <u>File1: server.c </u>
  #include <sys/types.h>
  #include <sys/ipc.h>
  #include <sys/shm.h>
  #include <stdio.h>
  #include <semaphore.h>
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <fcntl.h>

  #define SHMSZ 27

  char SEM_NAME[]= "vik";

  int main()
  {
      char ch;
      int shmid;
      key_t key;
      char *shm,*s;
      sem_t *mutex;

      //name the shared memory segment
      key = 1000;

      //create & initialize semaphore
      mutex = sem_open(SEM_NAME,O_CREAT,0644,1);
      if(mutex == SEM_FAILED)
      {
        perror("unable to create semaphore");
        sem_unlink(SEM_NAME);
        exit(-1);
      }

      //create the shared memory segment with this key
      shmid = shmget(key,SHMSZ,IPC_CREAT|0666);
      if(shmid<0)
  	{
          perror("failure in shmget");
          exit(-1);
  	}

      //attach this segment to virtual memory
      shm = shmat(shmid,NULL,0);

      //start writing into memory
      s = shm;
      for(ch='A';ch<='Z';ch++)
      {
          sem_wait(mutex);
          *s++ = ch;
          sem_post(mutex);
       }

      //the below loop could be replaced by binary semaphore
      while(*shm != '*')
      {
          sleep(1);
  	}

      sem_close(mutex);
      sem_unlink(SEM_NAME);
      shmctl(shmid, IPC_RMID, 0);
      exit(0);
  }
   

  // <u>File 2: client.c</u>
  #include <sys/types.h>
  #include <sys/ipc.h>
  #include <sys/shm.h>
  #include <stdio.h>
  #include <semaphore.h>
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <fcntl.h>

  #define SHMSZ 27

  char SEM_NAME[]= "vik";

  int main()
  {
      char ch;
      int shmid;
      key_t key;
      char *shm,*s;
      sem_t *mutex;

      //name the shared memory segment
      key = 1000;

      //create & initialize existing semaphore
      mutex = sem_open(SEM_NAME,0,0644,0);
      if(mutex == SEM_FAILED)
      {
          perror("reader:unable to execute semaphore");
          sem_close(mutex);
          exit(-1);
      } 

      //create the shared memory segment with this key
      shmid = shmget(key,SHMSZ,0666);
      if(shmid<0)
      {
          perror("reader:failure in shmget");
          exit(-1);
      }

      //attach this segment to virtual memory
      shm = shmat(shmid,NULL,0);

      //start reading
      s = shm;
      for(s=shm;*s!=NULL;s++)
      {
          sem_wait(mutex);
          putchar(*s);
          sem_post(mutex);
      }

      //once done signal exiting of reader:This can be replaced by another semaphore
      *shm = '*';
      sem_close(mutex);
      shmctl(shmid, IPC_RMID, 0);
      exit(0);
  }
  ```

  ​


* SYSTEM V信号量

  一个或多个信号量的集合，它对应的是一个信号量结构体，这个结构体是为SYSTEM V IPC服务的，信号量只不过是它的一部分

  常用于进程间同步

  ...




### source code

```c
int
__new_sem_wait (sem_t *sem)
{
  if (__new_sem_wait_fast ((struct new_sem *) sem, 0) == 0)
    return 0;
  else
    return __new_sem_wait_slow((struct new_sem *) sem, NULL);
}

// ...

/* Fast path: Try to grab a token without blocking.  */
static int
__new_sem_wait_fast (struct new_sem *sem, int definitive_result)
{
  /* We need acquire MO if we actually grab a token, so that this
     synchronizes with all token providers (i.e., the RMW operation we read
     from or all those before it in modification order; also see sem_post).
     We do not need to guarantee any ordering if we observed that there is
     no token (POSIX leaves it unspecified whether functions that fail
     synchronize memory); thus, relaxed MO is sufficient for the initial load
     and the failure path of the CAS.  If the weak CAS fails and we need a
     definitive result, retry.  */
#if __HAVE_64B_ATOMICS
  uint64_t d = atomic_load_relaxed (&sem->data);
  do
    {
      if ((d & SEM_VALUE_MASK) == 0)
	break;
      if (atomic_compare_exchange_weak_acquire (&sem->data, &d, d - 1))
	return 0;
    }
  while (definitive_result);
  return -1;
#else
  unsigned int v = atomic_load_relaxed (&sem->value);
  do
    {
      if ((v >> SEM_VALUE_SHIFT) == 0)
	break;
      if (atomic_compare_exchange_weak_acquire (&sem->value,
	  &v, v - (1 << SEM_VALUE_SHIFT)))
	return 0;
    }
  while (definitive_result);
  return -1;
#endif
}

// ...

/* Slow path that blocks.  */
static int
__attribute__ ((noinline))
__new_sem_wait_slow (struct new_sem *sem, const struct timespec *abstime)
{
  int err = 0;

#if __HAVE_64B_ATOMICS
  /* Add a waiter.  Relaxed MO is sufficient because we can rely on the
     ordering provided by the RMW operations we use.  */
  uint64_t d = atomic_fetch_add_relaxed (&sem->data,
      (uint64_t) 1 << SEM_NWAITERS_SHIFT);

  pthread_cleanup_push (__sem_wait_cleanup, sem);

  /* Wait for a token to be available.  Retry until we can grab one.  */
  for (;;)
    {
      /* If there is no token available, sleep until there is.  */
      if ((d & SEM_VALUE_MASK) == 0)
	{
	  err = do_futex_wait (sem, abstime);
	  /* A futex return value of 0 or EAGAIN is due to a real or spurious
	     wake-up, or due to a change in the number of tokens.  We retry in
	     these cases.
	     If we timed out, forward this to the caller.
	     EINTR is returned if we are interrupted by a signal; we
	     forward this to the caller.  (See futex_wait and related
	     documentation.  Before Linux 2.6.22, EINTR was also returned on
	     spurious wake-ups; we only support more recent Linux versions,
	     so do not need to consider this here.)  */
	  if (err == ETIMEDOUT || err == EINTR)
	    {
	      __set_errno (err);
	      err = -1;
	      /* Stop being registered as a waiter.  */
	      atomic_fetch_add_relaxed (&sem->data,
		  -((uint64_t) 1 << SEM_NWAITERS_SHIFT));
	      break;
	    }
	  /* Relaxed MO is sufficient; see below.  */
	  d = atomic_load_relaxed (&sem->data);
	}
      else
	{
	  /* Try to grab both a token and stop being a waiter.  We need
	     acquire MO so this synchronizes with all token providers (i.e.,
	     the RMW operation we read from or all those before it in
	     modification order; also see sem_post).  On the failure path,
	     relaxed MO is sufficient because we only eventually need the
	     up-to-date value; the futex_wait or the CAS perform the real
	     work.  */
	  if (atomic_compare_exchange_weak_acquire (&sem->data,
	      &d, d - 1 - ((uint64_t) 1 << SEM_NWAITERS_SHIFT)))
	    {
	      err = 0;
	      break;
	    }
	}
    }

  pthread_cleanup_pop (0);
#else
  /* The main difference to the 64b-atomics implementation is that we need to
     access value and nwaiters in separate steps, and that the nwaiters bit
     in the value can temporarily not be set even if nwaiters is nonzero.
     We work around incorrectly unsetting the nwaiters bit by letting sem_wait
     set the bit again and waking the number of waiters that could grab a
     token.  There are two additional properties we need to ensure:
     (1) We make sure that whenever unsetting the bit, we see the increment of
     nwaiters by the other thread that set the bit.  IOW, we will notice if
     we make a mistake.
     (2) When setting the nwaiters bit, we make sure that we see the unsetting
     of the bit by another waiter that happened before us.  This avoids having
     to blindly set the bit whenever we need to block on it.  We set/unset
     the bit while having incremented nwaiters (i.e., are a registered
     waiter), and the problematic case only happens when one waiter indeed
     followed another (i.e., nwaiters was never larger than 1); thus, this
     works similarly as with a critical section using nwaiters (see the MOs
     and related comments below).

     An alternative approach would be to unset the bit after decrementing
     nwaiters; however, that would result in needing Dekker-like
     synchronization and thus full memory barriers.  We also would not be able
     to prevent misspeculation, so this alternative scheme does not seem
     beneficial.  */
  unsigned int v;

  /* Add a waiter.  We need acquire MO so this synchronizes with the release
     MO we use when decrementing nwaiters below; it ensures that if another
     waiter unset the bit before us, we see that and set it again.  Also see
     property (2) above.  */
  atomic_fetch_add_acquire (&sem->nwaiters, 1);

  pthread_cleanup_push (__sem_wait_cleanup, sem);

  /* Wait for a token to be available.  Retry until we can grab one.  */
  /* We do not need any ordering wrt. to this load's reads-from, so relaxed
     MO is sufficient.  The acquire MO above ensures that in the problematic
     case, we do see the unsetting of the bit by another waiter.  */
  v = atomic_load_relaxed (&sem->value);
  do
    {
      do
	{
	  /* We are about to block, so make sure that the nwaiters bit is
	     set.  We need release MO on the CAS to ensure that when another
	     waiter unsets the nwaiters bit, it will also observe that we
	     incremented nwaiters in the meantime (also see the unsetting of
	     the bit below).  Relaxed MO on CAS failure is sufficient (see
	     above).  */
	  do
	    {
	      if ((v & SEM_NWAITERS_MASK) != 0)
		break;
	    }
	  while (!atomic_compare_exchange_weak_release (&sem->value,
	      &v, v | SEM_NWAITERS_MASK));
	  /* If there is no token, wait.  */
	  if ((v >> SEM_VALUE_SHIFT) == 0)
	    {
	      /* See __HAVE_64B_ATOMICS variant.  */
	      err = do_futex_wait(sem, abstime);
	      if (err == ETIMEDOUT || err == EINTR)
		{
		  __set_errno (err);
		  err = -1;
		  goto error;
		}
	      err = 0;
	      /* We blocked, so there might be a token now.  Relaxed MO is
		 sufficient (see above).  */
	      v = atomic_load_relaxed (&sem->value);
	    }
	}
      /* If there is no token, we must not try to grab one.  */
      while ((v >> SEM_VALUE_SHIFT) == 0);
    }
  /* Try to grab a token.  We need acquire MO so this synchronizes with
     all token providers (i.e., the RMW operation we read from or all those
     before it in modification order; also see sem_post).  */
  while (!atomic_compare_exchange_weak_acquire (&sem->value,
      &v, v - (1 << SEM_VALUE_SHIFT)));

error:
  pthread_cleanup_pop (0);

  __sem_wait_32_finish (sem);
#endif

  return err;
}

// ...

/* Wait until at least one token is available, possibly with a timeout.
   This is in a separate function in order to make sure gcc
   puts the call site into an exception region, and thus the
   cleanups get properly run.  TODO still necessary?  Other futex_wait
   users don't seem to need it.  */
static int
__attribute__ ((noinline))
do_futex_wait (struct new_sem *sem, const struct timespec *abstime)
{
  int err;

#if __HAVE_64B_ATOMICS
  err = futex_abstimed_wait_cancelable (
      (unsigned int *) &sem->data + SEM_VALUE_OFFSET, 0, abstime,
      sem->private);
#else
  err = futex_abstimed_wait_cancelable (&sem->value, SEM_NWAITERS_MASK,
					abstime, sem->private);
#endif

  return err;
}
```



## 结论

用到了。




# 中断处理程序ISR对进程执行的打算 && 为什么ISR里不能使用信号量



## 引子 - 同上



TODO
  ```

  ```