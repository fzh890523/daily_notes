
# java varargs parameter VS/AND potential heap pollution

```
过一下“Potential heap pollution via varargs parameter” 和 “http://stackoverflow.com/questions/21132692/java-unchecked-unchecked-generic-array-creation-for-varargs-parameter”这两个问题
```

[java-unchecked-unchecked-generic-array-creation-for-varargs-parameter](http://stackoverflow.com/questions/21132692/java-unchecked-unchecked-generic-array-creation-for-varargs-parameter)  
[potential-heap-pollution-via-varargs-parameter](http://stackoverflow.com/questions/12462079/potential-heap-pollution-via-varargs-parameter)

```
    public static <T> Collector<T, ?, int[]> summingMultiInt(ToIntFunction<? super T>... mappers) {
        int fields = mappers.length;
        return Collector.of(
                () -> new int[fields],
                (a, t) -> {
                    for (int i = 0; i < fields; i++) {
                        a[i] += mappers[i].applyAsInt(t);
                    }
                },
                (a, b) -> {
                    for (int i = 0; i < fields; i++) {
                        a[i] += b[i];
                    }
                    return a;
                },
                a -> a
        );
    }

```

## 跟进


### 概念： 堆污染 heap pollution
> ref: [oracle javase tutorial - nonReifiableVarargsType](https://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html)
> ref: [wiki - heap_pollution])(https://en.wikipedia.org/wiki/Heap_pollution)

**权威定义**
```
Heap Pollution

Heap pollution occurs when a variable of a parameterized type refers to an object that is not of that parameterized type. This situation occurs if the program performed some operation that gives rise to an unchecked warning at compile-time. An unchecked warning is generated if, either at compile-time (within the limits of the compile-time type checking rules) or at runtime, the correctness of an operation involving a parameterized type (for example, a cast or method call) cannot be verified. For example, heap pollution occurs when mixing raw types and parameterized types, or when performing unchecked casts.

In normal situations, when all code is compiled at the same time, the compiler issues an unchecked warning to draw your attention to potential heap pollution. If you compile sections of your code separately, it is difficult to detect the potential risk of heap pollution. If you ensure that your code compiles without warnings, then no heap pollution can occur.
```
指： 参数化类型的值中指向了一个非该参数化类型的“子值”

```java
class Container<T> {
    private Object value;
    public void add(T t) {
        value = t;
    }
    public T get() {
        return (T)value;
    }
    // 此时是ok的
    public void add(Object o) {
        value = o;
    }
    // 
} 
```


```
Heap pollution is a technical term. It refers to references which have a type that is not a supertype of the object they point to.

List<A> listOfAs = new ArrayList<>();
List<B> listOfBs = (List<B>)(Object)listOfAs; // points to a list of As

This can lead to "unexplainable" ClassCastExceptions.

// if the heap never gets polluted, this should never throw a CCE
B b = listOfBs.get(0); 

@SafeVarargs does not prevent this at all. However, there are methods which provably will not pollute the heap, the compiler just can't prove it. Previously callers of such APIs would get annoying warnings that were completely pointless, but had to be suppressed at every call site. Now the API author can suppress it once at the declaration site.

However, if the method actually is not safe, users will no longer be warned.

```


未完 TODO

# 网络知识盘点 - 摘录
看到一个博客写网络知识还比较全，备份一下。
> ref: [简单理解Socket](http://www.cnblogs.com/dolphinX/p/3460545.html)
> ref: [简单理解Socket - local](resource/简单理解Socket - Samaritans - 博客园.html)


# SOCKET类型 & proto类型


```
SOCK_STREAM： 提供面向连接的稳定数据传输，即TCP协议。
SOCK_DGRAM： 使用不连续不可靠的数据包连接。
SOCK_SEQPACKET： 提供连续可靠的数据包连接。
SOCK_RAW： 提供原始网络协议存取。
SOCK_RDM： 提供可靠的数据包连接。
SOCK_PACKET： 与网络驱动程序直接通信。

OOB： 在所有数据传送前必须使用connect()来建立连接状态。
```


```
protocol:协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等
```

## 使用
```c
int socket(int domain, int type, int protocol);
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
ssize_t read(int fd, void *buf, size_t count);
ssize_t write(int fd, const void *buf, size_t count);
int close(int fd);
```


## SOCK_SEQPACKET

参见： [Sequenced_Packets_Over_Ordinary_TCP - local](resource/Sequenced Packets Over Ordinary TCP.html) or [Sequenced_Packets_Over_Ordinary_TCP](http://urchin.earth.li/~twic/Sequenced_Packets_Over_Ordinary_TCP.html)

从参考资料里可以知道：
* **语义** 只是一种概念模型，不代表必然支持。 proto和socket_type之间不是全映射关系。
    - 面向连接
    - 基于包而不是流，也即传输的是packet（这里叫record）
    - 特殊协议字段`MSG_EOR`来指示record边界
    - 一次读写操作只会对一个record（哪怕只是一部分。 不会涉及多个record的部分）
    - 一个record如果过大等，可以通过多次读写操作来完成（参考UDP）
* **应用** 在TCP/IP协议栈里并无实现，其他协议栈里有
* **疑问** MSG_EOR边界怎么保证不和`record content`冲突？ 业务方指定吗？

```
Here is a good article on the intended use case for SOCK_SEQPACKET, the fact that it's not really available in the IP protocol families, and how you can get the same thing with existing TCP semantics:

http://urchin.earth.li/~twic/Sequenced_Packets_Over_Ordinary_TCP.html

Note that SOCK_SEQPACKET is much closer in behavior to SOCK_STREAM than to SOCK_DGRAM.

Citing from the referenced website:

The SOCK_SEQPACKET socket type is similar to the SOCK_STREAM type, and is also connection-oriented. The only difference between these types is that record boundaries are maintained using the SOCK_SEQPACKET type. A record can be sent using one or more output operations and received using one or more input operations, but a single operation never transfers parts of more than one record. Record boundaries are visible to the receiver via the MSG_EOR flag in the received message flags returned by the recvmsg() function. It is protocol-specific whether a maximum record size is imposed.
```

```
在IP(AF_INET)协议里并没有SOCK_SEQPACKET类型.
而是在IPX/SPX(AF_IPX ), NetBIOS (AF_NETBIOS)中才会出现.

所以你的 m_st =socket(AF_INET,SOCK_SEQPACKET,0); 不会成功.
```

## SOCK_DGRAM

### golang示例

#### APi解释
```golang
// ListenUnixgram listens for incoming Unix datagram packets addressed
// to the local address laddr.  The network net must be "unixgram".
// The returned connection's ReadFrom and WriteTo methods can be used
// to receive and send packets with per-packet addressing.
func ListenUnixgram(net string, laddr *UnixAddr) (*UnixConn, error) {
    switch net {
    case "unixgram":
    default:
        return nil, &OpError{Op: "listen", Net: net, Source: nil, Addr: laddr.opAddr(), Err: UnknownNetworkError(net)}
    }
    if laddr == nil {
        return nil, &OpError{Op: "listen", Net: net, Source: nil, Addr: nil, Err: errMissingAddress}
    }
    fd, err := unixSocket(net, laddr, nil, "listen", noDeadline)
    if err != nil {
        return nil, &OpError{Op: "listen", Net: net, Source: nil, Addr: laddr.opAddr(), Err: err}
    }
    return newUnixConn(fd), nil
}

// ListenUDP listens for incoming UDP packets addressed to the local
// address laddr.  Net must be "udp", "udp4", or "udp6".  If laddr has
// a port of 0, ListenUDP will choose an available port.
// The LocalAddr method of the returned UDPConn can be used to
// discover the port.  The returned connection's ReadFrom and WriteTo
// methods can be used to receive and send UDP packets with per-packet
// addressing.
func ListenUDP(net string, laddr *UDPAddr) (*UDPConn, error) {
    switch net {
    case "udp", "udp4", "udp6":
    default:
        return nil, &OpError{Op: "listen", Net: net, Source: nil, Addr: laddr.opAddr(), Err: UnknownNetworkError(net)}
    }
    if laddr == nil {
        laddr = &UDPAddr{}
    }
    fd, err := internetSocket(net, laddr, nil, noDeadline, syscall.SOCK_DGRAM, 0, "listen", noCancel)
    if err != nil {
        return nil, &OpError{Op: "listen", Net: net, Source: nil, Addr: laddr, Err: err}
    }
    return newUDPConn(fd), nil
}
```

#### 代码示例

server
```golang
conn, err := net.ListenUnixgram("unixgram",  &net.UnixAddr{"/tmp/unixdomain", "unixgram"})
if err != nil {
    panic(err)
}   
defer os.Remove("/tmp/unixdomain")

for {
    var buf [1024]byte
    n, err := conn.Read(buf[:])
    if err != nil {
        panic(err)
    }
    fmt.Printf("%s\n", string(buf[:n]));
}   
```

复杂点的UDP server（proxy）
```golang
func UdpLotusMain(ip string, port int) {
    //start tcp server
    addr, err := net.ResolveUDPAddr("udp", ip+":"+strconv.Itoa(port))
    if err != nil {
        log.Fatalln("net.ResolveUDPAddr fail.", err)
        return
    }
    conn, err := net.ListenUDP("udp", addr)
    if err != nil {
        log.Fatalln("net.ListenUDP fail.", err)
        //os.Exit(1)
        return
    }
    log.Println("start udp server " + ip + " " + strconv.Itoa(port))
    defer conn.Close()

    //start proxy connect and loop
    var tc Clienter
    tc.SendStr = make(chan *Request, 1000)
    tc.RecvStr = make(chan string)
    tc.Connect()
    go ProxySendLoop(&tc)
    go ProxyRecvLoop(&tc)

    //listen new request
    requestMap = make(map[int]*Request)

    buf := make([]byte, msg_length)
    var id int = 0
    for {
        rlen, remote, err := conn.ReadFromUDP(buf)
        if err == nil {
            id++
            log.Println("connected from " + remote.String())
            go handle(conn, remote, id, &tc, buf[:rlen]) //new thread
        }
    }
}
```

client
```
type := "unix" // or "unixgram" or "unixpacket"
laddr := net.UnixAddr{"/tmp/unixdomaincli", type}
conn, err := net.DialUnix(type, &laddr/*can be nil*/, 
    &net.UnixAddr{"/tmp/unixdomain", type})
if err != nil {
    panic(err)
}   
defer os.Remove("/tmp/unixdomaincli")

_, err = conn.Write([]byte("hello"))
if err != nil {
    panic(err)
}   
conn.Close()
```
> 竟然也是conn的语义。 = =


UDP client
```golang
func main() {

    addr, err := net.ResolveUDPAddr("udp", ":1987")
    if err != nil {
        fmt.Println("net.ResolveUDPAddr fail.", err)
        os.Exit(1)
    }

    socket, err := net.DialUDP("udp", nil, addr)
    if err != nil {
        fmt.Println("net.DialUDP fail.", err)
        os.Exit(1)
    }
    defer socket.Close()
    r := bufio.NewReader(os.Stdin)
    for {
        switch line, ok := r.ReadString('\n'); true {
        case ok != nil:
            fmt.Printf("bye bye!\n")
            return
        default:
            socket.Write([]byte(line))
            data := make([]byte, 1024)
            _, remoteAddr, err := socket.ReadFromUDP(data)
            if err != nil {
                fmt.Println("error recv data")
                return
            }
            fmt.Printf("from %s:%s\n", remoteAddr.String(), string(data))
        }
    }
}
```

### c示例

#### APi解释

#### 代码示例

server
```c
/* ud_ucase_sv.c

   A server that uses a UNIX domain datagram socket to receive datagrams,
   convert their contents to uppercase, and then return them to the senders.

   See also ud_ucase_cl.c.
*/
#include "ud_ucase.h"
int
main(int argc, char *argv[])
{
    struct sockaddr_un svaddr, claddr;
    int sfd, j;
    ssize_t numBytes;
    socklen_t len;
    char buf[BUF_SIZE];

    sfd = socket(AF_UNIX, SOCK_DGRAM, 0);       /* Create server socket */
    if (sfd == -1)
        errExit("socket");

    /* Construct well-known address and bind server socket to it */

    /* For an explanation of the following check, see the erratum note for
       page 1168 at http://www.man7.org/tlpi/errata/. */

    if (strlen(SV_SOCK_PATH) > sizeof(svaddr.sun_path) - 1)
        fatal("Server socket path too long: %s", SV_SOCK_PATH);

    if (remove(SV_SOCK_PATH) == -1 && errno != ENOENT)
        errExit("remove-%s", SV_SOCK_PATH);

    memset(&svaddr, 0, sizeof(struct sockaddr_un));
    svaddr.sun_family = AF_UNIX;
    strncpy(svaddr.sun_path, SV_SOCK_PATH, sizeof(svaddr.sun_path) - 1);

    if (bind(sfd, (struct sockaddr *) &svaddr, sizeof(struct sockaddr_un)) == -1)
        errExit("bind");

    /* Receive messages, convert to uppercase, and return to client */

    for (;;) {
        len = sizeof(struct sockaddr_un);
        numBytes = recvfrom(sfd, buf, BUF_SIZE, 0,
                            (struct sockaddr *) &claddr, &len);
        if (numBytes == -1)
            errExit("recvfrom");

        printf("Server received %ld bytes from %s\n", (long) numBytes,
                claddr.sun_path);

        for (j = 0; j < numBytes; j++)
            buf[j] = toupper((unsigned char) buf[j]);

        if (sendto(sfd, buf, numBytes, 0, (struct sockaddr *) &claddr, len) !=
                numBytes)
            fatal("sendto");
    }
}
```

client
```c
/* ud_ucase_cl.c

   A UNIX domain client that communicates with the server in ud_ucase_sv.c.
   This client sends each command-line argument as a datagram to the server,
   and then displays the contents of the server's response datagram.
*/
#include "ud_ucase.h"
int
main(int argc, char *argv[])
{
    struct sockaddr_un svaddr, claddr;
    int sfd, j;
    size_t msgLen;
    ssize_t numBytes;
    char resp[BUF_SIZE];

    if (argc < 2 || strcmp(argv[1], "--help") == 0)
        usageErr("%s msg...\n", argv[0]);

    /* Create client socket; bind to unique pathname (based on PID) */

    sfd = socket(AF_UNIX, SOCK_DGRAM, 0);
    if (sfd == -1)
        errExit("socket");

    memset(&claddr, 0, sizeof(struct sockaddr_un));
    claddr.sun_family = AF_UNIX;
    snprintf(claddr.sun_path, sizeof(claddr.sun_path),
            "/tmp/ud_ucase_cl.%ld", (long) getpid());

    if (bind(sfd, (struct sockaddr *) &claddr, sizeof(struct sockaddr_un)) == -1)
        errExit("bind");

    /* Construct address of server */

    memset(&svaddr, 0, sizeof(struct sockaddr_un));
    svaddr.sun_family = AF_UNIX;
    strncpy(svaddr.sun_path, SV_SOCK_PATH, sizeof(svaddr.sun_path) - 1);

    /* Send messages to server; echo responses on stdout */

    for (j = 1; j < argc; j++) {
        msgLen = strlen(argv[j]);       /* May be longer than BUF_SIZE */
        if (sendto(sfd, argv[j], msgLen, 0, (struct sockaddr *) &svaddr,
                sizeof(struct sockaddr_un)) != msgLen)
            fatal("sendto");

        numBytes = recvfrom(sfd, resp, BUF_SIZE, 0, NULL, NULL);
        /* Or equivalently: numBytes = recv(sfd, resp, BUF_SIZE, 0);
                        or: numBytes = read(sfd, resp, BUF_SIZE); */
        if (numBytes == -1)
            errExit("recvfrom");
        printf("Response %d: %.*s\n", j, (int) numBytes, resp);
    }

    remove(claddr.sun_path);            /* Remove client socket pathname */
    exit(EXIT_SUCCESS);
}
```