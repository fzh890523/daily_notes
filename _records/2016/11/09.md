
# java varargs parameter VS/AND potential heap pollution

```
过一下“Potential heap pollution via varargs parameter” 和 “http://stackoverflow.com/questions/21132692/java-unchecked-unchecked-generic-array-creation-for-varargs-parameter”这两个问题
```

[java-unchecked-unchecked-generic-array-creation-for-varargs-parameter](http://stackoverflow.com/questions/21132692/java-unchecked-unchecked-generic-array-creation-for-varargs-parameter)  
[potential-heap-pollution-via-varargs-parameter](http://stackoverflow.com/questions/12462079/potential-heap-pollution-via-varargs-parameter)

```
    public static <T> Collector<T, ?, int[]> summingMultiInt(ToIntFunction<? super T>... mappers) {
        int fields = mappers.length;
        return Collector.of(
                () -> new int[fields],
                (a, t) -> {
                    for (int i = 0; i < fields; i++) {
                        a[i] += mappers[i].applyAsInt(t);
                    }
                },
                (a, b) -> {
                    for (int i = 0; i < fields; i++) {
                        a[i] += b[i];
                    }
                    return a;
                },
                a -> a
        );
    }

```

## 跟进


### 概念： 堆污染 heap pollution
> ref: [oracle javase tutorial - nonReifiableVarargsType](https://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html)
> ref: [wiki - heap_pollution])(https://en.wikipedia.org/wiki/Heap_pollution)

**权威定义**
```
Heap Pollution

Heap pollution occurs when a variable of a parameterized type refers to an object that is not of that parameterized type. This situation occurs if the program performed some operation that gives rise to an unchecked warning at compile-time. An unchecked warning is generated if, either at compile-time (within the limits of the compile-time type checking rules) or at runtime, the correctness of an operation involving a parameterized type (for example, a cast or method call) cannot be verified. For example, heap pollution occurs when mixing raw types and parameterized types, or when performing unchecked casts.

In normal situations, when all code is compiled at the same time, the compiler issues an unchecked warning to draw your attention to potential heap pollution. If you compile sections of your code separately, it is difficult to detect the potential risk of heap pollution. If you ensure that your code compiles without warnings, then no heap pollution can occur.
```
指： 参数化类型的值中指向了一个非该参数化类型的“子值”

```java
class Container<T> {
    private Object value;
    public void add(T t) {
        value = t;
    }
    public T get() {
        return (T)value;
    }
    // 此时是ok的
    public void add(Object o) {
        value = o;
    }
    // 
} 
```


```
Heap pollution is a technical term. It refers to references which have a type that is not a supertype of the object they point to.

List<A> listOfAs = new ArrayList<>();
List<B> listOfBs = (List<B>)(Object)listOfAs; // points to a list of As

This can lead to "unexplainable" ClassCastExceptions.

// if the heap never gets polluted, this should never throw a CCE
B b = listOfBs.get(0); 

@SafeVarargs does not prevent this at all. However, there are methods which provably will not pollute the heap, the compiler just can't prove it. Previously callers of such APIs would get annoying warnings that were completely pointless, but had to be suppressed at every call site. Now the API author can suppress it once at the declaration site.

However, if the method actually is not safe, users will no longer be warned.

```


未完 TODO









