
# 记录一下java数组踩得坑： 
> ref: [how-to-create-a-generic-array-in-java](http://stackoverflow.com/questions/529085/how-to-create-a-generic-array-in-java)

```
public class GenSet<E> {
    private E a[];

    public GenSet() {
        a = new E[INITIAL_ARRAY_LENGTH]; // error: generic array creation
    }
}

How can I implement this while maintaining type safety?

I saw a solution on the Java forums that goes like this:

import java.lang.reflect.Array;

class Stack<T> {
    public Stack(Class<T> clazz, int capacity) {
        array = (T[])Array.newInstance(clazz, capacity);
    }

    private final T[] array;
}

But I really don't get what's going on. Can anyone help?
```

```
I have to ask a question in return: is your GenSet "checked" or "unchecked"? What does that mean?

    Checked: strong typing. GenSet knows explicitly what type of objects it contains (i.e. its constructor was explicitly called with a Class<E> argument, and methods will throw an exception when they are passed arguments that are not of type E. See Collections.checkedCollection.

    -> in that case, you should write:

    public class GenSet<E> {

        private E[] a;

        public GenSet(Class<E> c, int s) {
            // Use Array native method to create array
            // of a type only known at run time
            @SuppressWarnings("unchecked")
            final E[] a = (E[]) Array.newInstance(c, s);
            this.a = a;
        }

        E get(int i) {
            return a[i];
        }
    }

    Unchecked: weak typing. No type checking is actually done on any of the objects passed as argument.

    -> in that case, you should write

    public class GenSet<E> {

        private Object[] a;

        public GenSet(int s) {
            a = new Object[s];
        }

        E get(int i) {
            @SuppressWarnings("unchecked")
            final E e = (E) a[i];
            return e;
        }
    }

    Note that the component type of the array should be the erasure of the type parameter:

    public class GenSet<E extends Foo> { // E has an upper bound of Foo

        private Foo[] a; // E erases to Foo, so use Foo[]

        public GenSet(int s) {
            a = new Foo[s];
        }

        ...
    }

All of this results from a known, and deliberate, weakness of generics in Java: it was implemented using erasure, so "generic" classes don't know what type argument they were created with at run time, and therefore can not provide type-safety unless some explicit mechanism (type-checking) is implemented.

```

## 理解

我们知道，可以返回 `List<E>`
```java
<E> List<E> getL(Class<E> cls) {
    List<E> l = new ArrayList<>();
    // ... 
    return l;
}
```

甚至
```java
<E> List<E> getL() {
    // ...
}

List<Integer> l = getL();
```
> 因为可以根据返回值确定类型。 而实际上，因为类型擦除，List<E> 只是 List 或 List<Object>，可以只要能通过编译层面的类型检查，怎么new怎么return都是ok的。

### E[] 不能new
```java
<E> void f(int l) {
    E[] arr = new E[l];
}
```

估计是f在生成字节码时要确定E[]的类型吧，而f虽然在调用时可以确定E，但编译f本身时是不能的，所以没法new E[]。

### List<E> vs E[]

根据java泛型类型擦除，List<E>在字节码和运行时阶段并不带有E的类型信息；而E[]等于 type: array of E，是带有具体E的类型信息的。

原先以为 `List<E>.toArray()` 返回 E[]是OK的，后来发现想当然了，不可凭空恢复出E类型信息来。 List<E> 内部只能是 Object[] 或者 Object -> Object 的存在。

那么，前面也提到了E[]不能new，那么要如何生成呢？
上面so的链接里也提到了，要么放弃E[]采用其他wrap方式，比如List<E> 或者 自定义的。
```java
class TArr<E> {
    Object[] arr;
    public TArr(int l) {
        arr = new Object[l];
    }
    public E get(int i) {
        return (E)arr[i];
    }
    public E set(int i, E e) {
        arr[i] = e;
    }
}
```
> Object[] 虽然是 type: array of object，但anything都是object，所以可以存。 而取出来以后因为实例的实际类型还在所以可以强转。

还有就是用`Array.newIntance(Class<E> cls, int l)`运行时生成特定的array类型实例，所以需要传入类型信息，也即需要class实例，使用起来就没有泛型方便了。
不过这里为什么要`@SuppressWarnings("unchecked")`就不太理解了。

