
# linux中mv操作会改变ctime

atime： access，内容读取
mtime： modify，内容修改
ctime： change，inode修改

> 一度恍惚了，以为ctime只是指create time

mv的

```
# root @ local_centos in /tmp [18:35:20] tty:pts/6 L:1 N:69
$ stat t.c
  File: ‘t.c’
  Size: 293             Blocks: 8          IO Block: 4096   regular file
Device: fd00h/64768d    Inode: 102426448   Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Context: unconfined_u:object_r:user_tmp_t:s0
Access: 2016-11-08 14:13:53.461081496 +0800
Modify: 2016-11-08 14:13:50.701061952 +0800
Change: 2016-11-08 14:13:50.701061952 +0800
 Birth: -

# root @ local_centos in /tmp [18:35:25] tty:pts/6 L:1 N:70
$ mv t.c t1.c

# root @ local_centos in /tmp [18:35:55] tty:pts/6 L:1 N:71
$ stat t1.c  
  File: ‘t1.c’
  Size: 293             Blocks: 8          IO Block: 4096   regular file
Device: fd00h/64768d    Inode: 102426448   Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Context: unconfined_u:object_r:user_tmp_t:s0
Access: 2016-11-08 14:13:53.461081496 +0800
Modify: 2016-11-08 14:13:50.701061952 +0800
Change: 2016-11-10 18:35:55.631759365 +0800
 Birth: -
```


## ctime修改场景
```
A long, long time ago, the command

mv oldpath newpath
was implemented inside mv.c as

link(oldpath, newpath);
unlink(newpath);
Now we have a system call

rename(oldpath, newpath);
but apparently it still works the same way, inside the kernel.  This is a conjecture on my part, but it’s based on the fact that one of the failure modes for rename(2) is

EMLINK

oldpath already has the maximum number of links to it, or ...
and based on the experimental data that you reported (and that I confirmed on my own system).

And so...

When oldpath gets linked to newpath, the inode’s link count goes up by one.  When oldpath gets unlinked, the inode’s link count goes down by one. Therefore, the inode gets changed (even though it immediately gets changed back to the way it was before).

P.S. It’s interesting to note that the POSIX document lists EMLINK as a possible error return code, but not for the case of file-to-file rename.
```

```
# root @ local_centos in /tmp [18:35:57] tty:pts/6 L:1 N:72
$ cp --help | grep "\-p"
  -a, --archive                same as -dR --preserve=all
  -d                           same as --no-dereference --preserve=links
  -p                           same as --preserve=mode,ownership,timestamps
      --preserve[=ATTR_LIST]   preserve the specified attributes (default:
  -c                           deprecated, same as --preserve=context
      --no-preserve=ATTR_LIST  don't preserve the specified attributes
      --parents                use full source file name under DIRECTORY
```

## create time如何获得？
```
The field gets populated (see below) only coreutils stat does not display it. Apparently they're waiting1 for the xstat() interface.

coreutils patches - aug. 2012 - TODO

stat(1) and ls(1) support for birth time. Dependent on xstat() being provided by the kernel
You can get the creation time via debugfs:

debugfs -R 'stat <inode_number>' DEVICE
e.g. for my /etc/profile which is on /dev/sda2 (see How to find out what device a file is on):

stat -c %i /etc/profile
398264
debugfs -R 'stat <398264>' /dev/sda2
debugfs 1.42.5 (29-Jul-2012)
Inode: 398264   Type: regular    Mode:  0644   Flags: 0x80000
Generation: 2058737571    Version: 0x00000000:00000001
User:     0   Group:     0   Size: 562
File ACL: 0    Directory ACL: 0
Links: 1   Blockcount: 8
Fragment:  Address: 0    Number: 0    Size: 0
 ctime: 0x506b860b:19fa3c34 -- Wed Oct  3 02:25:47 2012
 atime: 0x50476677:dcd84978 -- Wed Sep  5 16:49:27 2012
 mtime: 0x506b860b:19fa3c34 -- Wed Oct  3 02:25:47 2012
crtime: 0x50476677:dcd84978 -- Wed Sep  5 16:49:27 2012
Size of extra inode fields: 28
EXTENTS:
(0):3308774
```

```
root@dapper-app-02:/tmp # debugfs -R 'stat boot_result' /dev/vda1      
debugfs 1.42.12 (29-Aug-2014)
boot_result: File not found by ext2_lookup 

root@dapper-app-02:/tmp # debugfs -R 'stat -c %i boot_result' /dev/vda1                                      
debugfs 1.42.12 (29-Aug-2014)
stat: Usage: stat <file>

root@dapper-app-02:/tmp # stat -c %i boot_result 
915312

root@dapper-app-02:/tmp # debugfs -R 'stat <915312>' /dev/vda1           
debugfs 1.42.12 (29-Aug-2014)
Inode: 915312   Type: regular    Mode:  0644   Flags: 0x80000
Generation: 1725761263    Version: 0x00000000:00000001
User:     0   Group:     0   Size: 84
File ACL: 0    Directory ACL: 0
Links: 1   Blockcount: 8
Fragment:  Address: 0    Number: 0    Size: 0
 ctime: 0x5785dfeb:3fe56c00 -- Wed Jul 13 14:30:03 2016
 atime: 0x582450df:ee18adf0 -- Thu Nov 10 18:50:07 2016
 mtime: 0x5785dfeb:3fe56c00 -- Wed Jul 13 14:30:03 2016
crtime: 0x5785dfe9:3567e000 -- Wed Jul 13 14:30:01 2016
Size of extra inode fields: 28
EXTENTS:
(0):3705356
```


但是！ xfs不支持。

```
XFS does not support creation time. It just has the regular atime, mtime and ctime. There are no plans that I've heard to support it
Source: http://comments.gmane.org/gmane.comp.file-systems.xfs.general/20629
```

```
/dev/sdb               /data            xfs   defaults        0 0

# root @ local_centos in /tmp [18:45:09] tty:pts/6 L:1 N:84
$ debugfs -R 'stat -c %i /data/tmp/t1.c' /dev/sdb     
debugfs 1.42.9 (28-Dec-2013)
/dev/sdb: Bad magic number in super-block while opening filesystem
stat: Filesystem not open
```

### golang中的create time

```golang
type Stat_t struct {
    Dev       uint64
    Ino       uint64
    Nlink     uint64
    Mode      uint32
    Uid       uint32
    Gid       uint32
    X__pad0   int32
    Rdev      uint64
    Size      int64
    Blksize   int64
    Blocks    int64
    Atim      Timespec
    Mtim      Timespec
    Ctim      Timespec
    X__unused [3]int64
}
```

也没有crtime。

# 随手写的go sort工具
```golang
type fileInfos struct {
    data []*fileInfo
    cmp  func(fi1, fi2 *fileInfo) int
}

func (fis fileInfos) Len() int {
    return len(fis.data)
}
func (fis fileInfos) Less(i, j int) bool {
    return fis.cmp(fis.data[i], fis.data[j]) < 0
}
func (fis fileInfos) Swap(i, j int) {
    fis.data[i], fis.data[j] = fis.data[j], fis.data[i]
}
```

data改为`[]interface`就可以了。
