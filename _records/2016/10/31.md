
# java byte（int8）转为对应的uint8

```python
In [15]: -26 & 0xFF
Out[15]: 230

In [16]: hex(-26 & 0xFF)
Out[16]: '0xe6'

In [17]: hex(-26)       
Out[17]: '-0x1a'

In [22]: ord("\xe6")
Out[22]: 230
```

可以看到，py里的用uint8表示一个byte。而java里则是int8。
有时为了查看java里的byte[]（打成hex），需要...

## 在java里
idea的断点里没法直接复制byte[]的值，如果不长的的话，全部选中然后复制的话也只能得到下面的
```
0 = -26
1 = -120
2 = -111
3 = -28
4 = -69
5 = -84
```

做evaluate（默认expression mode）的话：
```java
System.out.println(String.join(",", Arrays.asList(bs2).stream().map(b -> Integer.valueOf(b & 0xFF).toString()).collect(Collectors.toList())))
```
提示： `Lambdas evaluation is not supported`

只能用`code segment mode`
```java
List<String> stringList = new ArrayList<>(bs2.length);
for(byte b: bs2) {
    stringList.add(Integer.valueOf(b & 0xFF).toString());
}
String.format("[%s]", String.join(",", stringList));
```
然后就可以在result里复制这个返回的字符串了。


> 如果有apache common-codec 的dependency的话，可以直接 `Hex.encodeHex(bs2)`

## 在python里

```python
In [16]: hex(-26 & 0xFF)
Out[16]: '0xe6'

In [17]: hex(-26)       
Out[17]: '-0x1a'

In [22]: ord("\xe6")
Out[22]: 230
```

那么：
```python
[b & 0xFF for b in bs]
```

# java 中 byte
```java
    public void testByteString() throws Exception {
        String.join(",", Arrays.asList("a", "b"));
        byte[] bs = "我们".getBytes();  // {-23, -114, -76, -26, -120, -100, -26, -69, -111}，也即 [233, 142, 180, 230, 136, 156, 230, 187, 145]，也即 ['0xe9', '0x8e', '0xb4', '0xe6', '0x88', '0x9c', '0xe6', '0xbb', '0x91']
        byte[] bs1 = "我们".getBytes("UTF-8");  // {-23, -114, -76, -26, -120, -100, -26, -69, -111}
        Assert.assertFalse(!Arrays.equals(bs1, bs));
        String s = new String(bs);
        byte[] bs2 = "我们".getBytes("GBK");  //  {-26, -120, -111, -28, -69, -84}，也即 [230, 136, 145, 228, 187, 172]，也即 ['0xe6', '0x88', '0x91', '0xe4', '0xbb', '0xac']
        String s1 = new String(bs2);
        Assert.assertFalse(!Arrays.equals(s.getBytes(), bs));
    }
```

```python
In [29]: s = "我们"

In [30]: len(s)
Out[30]: 6

In [31]: len(s.decode("utf-8").encode("gbk"))
Out[31]: 4

In [35]: [i for i in s]
Out[35]: ['\xe6', '\x88', '\x91', '\xe4', '\xbb', '\xac']
```


## 跟进
```
遇到一个奇怪的事情。
byte[] bs = "我们".getBytes();  // {-23, -114, -76, -26, -120, -100, -26, -69, -111}
byte[] bs1 = "我们".getBytes("UTF-8");  // {-23, -114, -76, -26, -120, -100, -26, -69, -111} -> ?? encoding
byte[] bs2 = "我们".getBytes("GBK");  //  {-26, -120, -111, -28, -69, -84} -> utf-8 encoding

有人知道为什么吗？ = =

为什么尝试获取GBK编码得到的是utf-8编码； 而尝试获取utf-8编码却得到不知道什么编码

分别是：
\xe9\x8e\xb4\xe6\x88\x9c\xe6\xbb\x91
\xe6\x88\x91\xe4\xbb\xac

是啊。 我当时扫一眼就发现字节数都不对，于是仔细看了下... 懵逼了。

嗯我也这么猜。 把这段代码copy到linux console下跑是ok的。


@yonka@bilibili 我知道什么问题了
知道这蓝色的我怎么弄出来的？

文件的encoding
对吗？

代码文件本身编码
最开始我是utf8

噗。 确实是低级问题了。
py里经常踩这个坑，java没往这方面想。
```


看了下。
在idea settings里，encoding相关的配置有：
* IDE encoding
* Project encoding
* default encoding for properties files

但都已经是“utf-8"了。
经群友提示，在test case的run/debug conf里加了` -Dfile.encoding=utf-8`并且（jinfo查看suspend的程序）确认生效。 但还是不行。

## 结论
最后发现，是idea生成的class文件里的字符串常量错误。
流程如下：
1. java source里的源代码字符串： 我们 -> 正确utf-8编码 -> `\xe6\x88\x91\xe4\xbb\xac`
2. idea用gbk去load源码文件并且用utf-8编码字符串常量（存放于class文件对应位置）。这一步就从 `6 byte/2 utf char` -> `3 gbk char` -> `3 utf-8 char/9 byte`了
...

然而前面说了，所有能配置encoding的地方都配成了utf-8，为什么idea还这样？

