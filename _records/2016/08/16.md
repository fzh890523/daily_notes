
# ETL解释
> ref: [ETL wiki](https://zh.wikipedia.org/wiki/ETL)

```
ETL，是英文Extract-Transform-Load的縮寫，用來描述將資料從來源端經過萃取（extract）、轉置（transform）、載入（load）至目的端的過程。
...
ETL（or ELT）的流程可以用任何的程式語言去開發完成，由於ETL是極為複雜的過程，而手寫程式不易管理，有愈來愈多的企業採用工具協助ETL的開發，並運用其內建的metadata功能來儲存來源與目的的對應（mapping）以及轉換規則。

工具並可以提供較強大的連接功能（connectivity）來連接來源及目的端，開發人員不用去熟悉各種相異的平台及資料的結構，亦能進行開發。

當然，為了這些好處，付出的代價便是金錢。
```


# msys2 和 git bash 情况下用的ssh key不同

## print git使用的ssh key的方式
`ssh -v git@bitbucket.org`

## log

msys2
```
# bili @ ZJ0271 in /e/yonka/git/yonka/work/bb on git:master o [12:51:35] tty:pty1 L:1 N:23
$ ssh -v git@bitbucket.org
OpenSSH_7.1p2, OpenSSL 1.0.2d 9 Jul 2015
debug1: Reading configuration data /etc/ssh/ssh_config
debug1: Connecting to bitbucket.org [104.192.143.3] port 22.
debug1: Connection established.
debug1: key_load_public: No such file or directory
debug1: identity file /home/bili/.ssh/id_rsa type -1
debug1: key_load_public: No such file or directory
debug1: identity file /home/bili/.ssh/id_rsa-cert type -1
debug1: key_load_public: No such file or directory
debug1: identity file /home/bili/.ssh/id_dsa type -1
debug1: key_load_public: No such file or directory
debug1: identity file /home/bili/.ssh/id_dsa-cert type -1
debug1: key_load_public: No such file or directory
debug1: identity file /home/bili/.ssh/id_ecdsa type -1
debug1: key_load_public: No such file or directory
debug1: identity file /home/bili/.ssh/id_ecdsa-cert type -1
debug1: key_load_public: No such file or directory
debug1: identity file /home/bili/.ssh/id_ed25519 type -1
debug1: key_load_public: No such file or directory
debug1: identity file /home/bili/.ssh/id_ed25519-cert type -1
debug1: Enabling compatibility mode for protocol 2.0
debug1: Local version string SSH-2.0-OpenSSH_7.1
debug1: Remote protocol version 2.0, remote software version conker_1.0.226.0482edc app-127
debug1: no match: conker_1.0.226.0482edc app-127
debug1: Authenticating to bitbucket.org:22 as 'git'
debug1: SSH2_MSG_KEXINIT sent
debug1: SSH2_MSG_KEXINIT received
debug1: kex: server->client aes128-ctr hmac-sha2-256 none
debug1: kex: client->server aes128-ctr hmac-sha2-256 none
debug1: expecting SSH2_MSG_KEX_ECDH_REPLY
debug1: Server host key: ssh-rsa SHA256:zzXQOXSRBEiUtuE8AikJYKwbHaxvSc0ojez9YXaGp1A
debug1: Host 'bitbucket.org' is known and matches the RSA host key.
debug1: Found key in /home/bili/.ssh/known_hosts:3
debug1: SSH2_MSG_NEWKEYS sent
debug1: expecting SSH2_MSG_NEWKEYS
debug1: SSH2_MSG_NEWKEYS received
debug1: SSH2_MSG_SERVICE_REQUEST sent
debug1: SSH2_MSG_SERVICE_ACCEPT received
debug1: Authentications that can continue: publickey
debug1: Next authentication method: publickey
debug1: Trying private key: /home/bili/.ssh/id_rsa
debug1: Trying private key: /home/bili/.ssh/id_dsa
debug1: Trying private key: /home/bili/.ssh/id_ecdsa
debug1: Trying private key: /home/bili/.ssh/id_ed25519
debug1: No more authentication methods to try.
Permission denied (publickey).
```

```
# bili @ ZJ0271 in /e/yonka/git/yonka/work/bb on git:master x [12:53:33] tty:pty1 L:1 N:27
$ echo $HOME
/c/Users/bili
```

```
# bili @ ZJ0271 in /e/yonka/git/yonka/work/bb on git:master x [12:59:38] tty:pty1 L:1 N:12
$ cat /etc/fstab
# For a description of the file format, see the Users Guide
# http://cygwin.com/cygwin-ug-net/using.html#mount-table

# DO NOT REMOVE NEXT LINE. It remove cygdrive prefix from path
none / cygdrive binary,posix=0,noacl,user 0 0
none /tmp usertemp binary,posix=0,noacl 0 0
C:/Users /home ntfs binary,noacl,auto 1 1

...


# bili @ ZJ0271 in /e/yonka/git/yonka/work/bb on git:master x [12:59:14] tty:pty1 L:1 N:10
$ mount
C:/Users on /home type ntfs (binary,noacl,user)
C:/msys64 on / type ntfs (binary,noacl,auto)
C:/msys64/usr/bin on /bin type ntfs (binary,noacl,auto)
C:/Users/bili/AppData/Local/Temp on /tmp type ntfs (binary,noacl,posix=0,usertemp)
C: on /c type ntfs (binary,noacl,posix=0,user,noumount,auto)
D: on /d type ntfs (binary,noacl,posix=0,user,noumount,auto)
```

# 判断是否支持webp
> ref: [判断是否支持WebP](http://www.cnblogs.com/zhishaofei/p/4191418.html)

```
判断是否支持WebP
PC端，触屏版：

前端JS方案——利用img标签加载一张base64的WebP图片，在img标签的onload事件中判断该图片是否具有宽高的属性，若有表示支持webP，若没有表示不支持webP。后台判断方案——判断浏览器请求头Accept是否支持WebP，返回是否支持的标示给前台。

以上两种方案中，前端方案为佳，当JS被禁止的时候，可以使用后台判断方式执行判断。附上JS代码截图



iOS独立版：

用户直接拉取WebP格式的图片（如果CDN有存储），下载完成后在前端实时转码（前端开发的WebP sdk），将WebP图片转换为jpg或png图片。展示给用户的是普通图片。

这样做的好处在于下载WebP的时候节省了带宽，虽然在转码的时候会耗时，但是由于下载时间缩短中和了转码的时间，所以用户基本感觉不出来差别。我们在不延长用户等待时间的同时缩小图片体积，节省了带宽。

安卓独立版：

后台判断用户机器系统，当系统版本大于4.0的时候返回支持WebP标示（因为其原生支持），前端拉取图片时后台会根据这个标示决定使用原格式图片还是WebP格式的图片。

兼容方案
对于不支持WebP的浏览器，可根据是否支持WebP的判断来拉取jpg或者png图片，也可以使用flash作为载体来加载WebP图片（空间相册兼容低端浏览器方案） 。

关于用户下载图片
PC和webview方案中，用户若想将图片另存为本地（可能本地不支持WebP预览展示），可在用户右击“另存为”的时候，绑定右击事件，加载当前WebP图片对应的jpg图片，然后直接下载jpg图片（空间相册方案） 。

虽然这样的做法会导致多加载一张图片，但是由于只在右击时候触发加载，而且用户右击“另存为”的行为较少，消耗可不计。
```

# HSTS preloading

对于支持https的站点：
1. 用户/浏览器并不知道支持，于是通常对于http请求，重定向到https
2. 1仍有问题，第一个请求仍然可能被劫持。 需要`Strict-Transport-Security`头来指示（告诉浏览器）该站需要用https，该头会被浏览器缓存，此后即使用户使用http也会被强制转为https
3. 2仍有问题，（“有史以来”）第一个请求时并没有缓存的该头。 浏览器需要通过其他方式来获知： 把该站点的该信息嵌入浏览器源码。
> google牵头搞了个网站可以申请为站点设置...： [hstspreload](https://hstspreload.appspot.com/)。 各大浏览器都资词...。
